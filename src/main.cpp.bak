#include <iostream>
#include <GL/gl3w.h>
#include <GLFW/glfw3.h>

#include "shader.h"
#include "input_layer.h"
#include "render_cubes.h"
#include "camera.h"
#include "SAT_collision_testing.h"
#include "collision_resolution.h"

// Dear IMGUI
#include "imgui/imgui.h"
#include "imgui/imgui_impl_opengl3.h"
#include "imgui/imgui_impl_glfw.h"

#define WIN_WIDTH	640
#define WIN_HEIGHT	480
#define WIN_NAME	"Test"


void temp_error_callback(int error_code, const char* descr) {
	std::cout << "GLFW Error: " << error_code << " " << descr << std::endl;
}

// INPUT MOUSE CALLBACk
void key_callback(GLFWwindow *wind, int key, int scancode, int action, int mods) {
	// ESC to close the game
	if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS) {
		glfwSetWindowShouldClose(wind, GL_TRUE);
	}

	eKeyMaps pressed_key;
	switch(key) {
		case GLFW_KEY_W:
			pressed_key = W_KEY;
			break;
		case GLFW_KEY_A:
			pressed_key = A_KEY;
			break;
		case GLFW_KEY_S:
			pressed_key = S_KEY;
			break;
		case GLFW_KEY_D:
			pressed_key = D_KEY;
			break;
		case GLFW_KEY_UP:
			pressed_key = UP_KEY;
			break;
		case GLFW_KEY_DOWN:
			pressed_key = DOWN_KEY;
			break;
		case GLFW_KEY_RIGHT:
			pressed_key = RIGHT_KEY;
			break;
		case GLFW_KEY_LEFT:
			pressed_key = LEFT_KEY;
			break;

		sInputLayer *input = get_game_input_instance();
		input->keyboard[pressed_key] = (action == GLFW_PRESS) ? KEY_PRESSED : KEY_RELEASED;
	};


}

void mouse_button_callback(GLFWwindow *wind, int button, int action, int mods) {
	char index;

	switch (button) {
	case GLFW_MOUSE_BUTTON_LEFT:
		index = LEFT_CLICK;
		break;

	case GLFW_MOUSE_BUTTON_RIGHT:
		index = RIGHT_CLICK;
		break;

	case GLFW_MOUSE_BUTTON_MIDDLE:
		index = MIDDLE_CLICK;
		break;
	}

	sInputLayer *input = get_game_input_instance();
	input->mouse_clicks[index] = (action == GLFW_PRESS) ? KEY_PRESSED : KEY_RELEASED;
}

void cursor_enter_callback(GLFWwindow *window, int entered) {
	sInputLayer *input = get_game_input_instance();
	input->is_mouse_on_screen = entered;
}

void get_projection_matrix(sMat44 *result, float vp_width, float vp_height) {
    result->set_identity();

    float left = (-vp_width) * 0.06f / 2.0f;
    float right = (vp_width) * 0.06f / 2.0f;
    float bottom = (-vp_height) * 0.06f / 2.0f;
    float top = (vp_height) * 0.06f / 2.0f;

    result->mat_values[0][0] = 2.0f / (right - left);
    result->mat_values[1][1] = 2.0f / (top - bottom);
    result->mat_values[2][2] = -1.0f;
    result->mat_values[3][0] = -(right + left) / (right - left);
    result->mat_values[3][1] = -(top + bottom) / (top - bottom);
}

sVector3 rotate_arround(const sVector3 pos, 
                        const sVector3 center, 
                        const float angle) {
  float x = pos.x - center.x, z = pos.z - center.z;
  float s = sin(angle), c = cos(angle);

  float nx = pos.x * c - pos.z * s;
  float nz = pos.x * s + pos.z * c;

  return sVector3{nx + center.x, pos.y, nz + center.z};
}

void draw_loop(GLFWwindow *window) {
	glfwMakeContextCurrent(window);

	sMat44 models[10];
	sVector4 colors[10] = {{}};
	sQuaternion4 rotations[10] = {{}};

  sMat44 models_col[10];
	sVector4 colors_col[10] = {{}};

  sCollisionResolution phys_engine;

	//rotations[0] = {0.917f, 0.0f, 0.f, -0.383f};
	rotations[0] = {1.0f, 0.0f, 0.0f, 0.0f};
  rotations[1] = {1.0f, 0.0f, 0.0f, 0.0f};

	phys_engine.models[0].set_scale({9.80f, 1.0f, 9.90f});
	//models[0].rotate(&rotations[0]);
	phys_engine.models[0].set_position({-4.5f, -2.5f, -4.50f});
	colors[0] = {1.0f, 1.0f, 1.0f, 1.0f};

	//models[1].set_scale({4.15, 1.05, 1.0f});
  //models[1].set_scale({1.0f, 1.0f, 1.0f});
	//models[1].rotate(&rotations[1]);
	phys_engine.models[1].set_position({-2.5, 2.2, 0.0f});
	colors[1] = {0.0f, 1.0f, .0f, 1.0f};

  phys_engine.models[2].set_position({-2.0, 4.2, 0.0f});
	colors[2] = {0.0f, 1.0f, 1.0f, 1.0f};

  phys_engine.models[3].set_position({2.5, 1.2, 5.0f});
	colors[3] = {1.0f, 1.0f, .0f, 1.0f};

  phys_engine.enabled[0] = true;
  phys_engine.enabled[1] = true;
  phys_engine.enabled[2] = true;
  phys_engine.enabled[3] = true;

  phys_engine.attribs[0] = IS_STATIC;

  phys_engine.mass[0] = 5.0f;
  phys_engine.mass[1] = 10.0f;
  phys_engine.mass[2] = 15.0f;
  phys_engine.mass[3] = 6.0f;

	sCubeRenderer renderer;
	cube_renderer_init(&renderer);

	double prev_frame_time = glfwGetTime();
	sInputLayer *input_state = get_game_input_instance();

  sCamera camera;

  //camera.right = sVector3{0.0f, 0.0f, 3.0f};
  //camera.up = sVector3{0.0f, 0.f, 0.f};
  //camera.forward = sVector3{0.0f, 1.0f, 0.f};
  camera.position = sVector3{5.0f, 1.0f, 5.0f}; 

  float camera_rot = 0.0f;
	while(!glfwWindowShouldClose(window)) {
		// Draw loop
		int width, heigth;
		double temp_mouse_x, temp_mouse_y;

    glfwPollEvents();
		glfwGetFramebufferSize(window, &width, &heigth);
		// Set to OpenGL viewport size anc coordinates
		glViewport(0,0, width, heigth);

		sMat44 proj_mat;	

		// OpenGL stuff
    glEnable(GL_DEPTH_TEST);  
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		glClearColor(0.5f, 0.5f, 0.5f, 1.0f);

    ImGui_ImplOpenGL3_NewFrame();
    ImGui_ImplGlfw_NewFrame();
    ImGui::NewFrame();

		double curr_frame_time = glfwGetTime();
		double elapsed_time = curr_frame_time - prev_frame_time;

    camera_rot = 1.10f; 
    camera.position = rotate_arround(camera.position, 
                                     sVector3{0.0f, 0.0f, 0.0f}, 
                                     to_radians(camera_rot));
  
    camera.look_at(sVector3{0.0f, 0.0f, 0.0f});
    camera.get_perspective_viewprojection_matrix(90.0f, 
                                                1000.0f,
                                                0.001f,
                                                (float)width / (float)heigth,
                                                &proj_mat);

    //camera.look_at(positions[1]);
		// Mouse position control
		glfwGetCursorPos(window, &temp_mouse_x, &temp_mouse_y);

    /*ImGui::Begin("Position data");
    ImGui::Text("Camera pos %f %f %f angle: %f", camera.position.x, camera.position.y, camera.position.z, camera_rot);
    for (int i = 0; i < 2; i++) {
      ImGui::Text("Obj: %i", i);
      ImGui::Text("Pos: x: %f y: %f z: %f", models[i].px, models[i].py, models[i].pz);
      ImGui::Text("Rot: %f %f %f %f", rotations[i].x, rotations[i].y, rotations[i].z, rotations[i].w);
      ImGui::Separator();
    }
    ImGui::End();*/

    phys_engine.update_positions(elapsed_time);

		// Test collisions
    ImGui::Begin("Collision data");

    int to_render_index = 0;
    sCollisionManifold manifold;
		for(int i = 0; i < 3; i++) {
			for(int j = i; j < 3; j++) {
				if (i == j) {
					continue;
				}
        sBoxCollider col1, col2;
        col1.modify(phys_engine.models[i], 
                    rotations[i]);

        col2.modify(phys_engine.models[j], 
                    rotations[j]);

        manifold.obj1_index = i;
        manifold.obj2_index = j;

        if (SAT_test_OBB_v_OBB(col1, col2, &manifold)) {
          std::cout << "Collision detected" << std::endl;
          //ImGui::Text("Collision between %i and %i", i, j); 
          for(int i = 0; i < manifold.contact_point_count; i++) {
            models_col[i].set_scale({0.1f, 0.1f, 0.1f});
            models_col[i].set_position(manifold.contact_points[i]);
            colors_col[i] = {1.0f, 0.0f, 0.0f};
          }

          cube_renderer_render(&renderer, models_col, colors_col, manifold.contact_point_count, &proj_mat);
          phys_engine.resolve_collision(manifold);
        } else {
          std::cout << "No collision detected" << std::endl;
        }        
		  }
    }
    ImGui::End();

    int min_shapes = 0; 
		cube_renderer_render(&renderer, phys_engine.models, colors, 3, &proj_mat);
    //cube_renderer_render(&renderer, models, colors, 2, &proj_mat);
    cube_renderer_render(&renderer, models_col, colors_col, manifold.contact_point_count, &proj_mat);
		std::cout << " ======== Frame end ======= " << std::endl; 

    ImGui::Render();
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

		glfwSwapBuffers(window);
	}
}

int main() {
	if (!glfwInit()) {
		return EXIT_FAILURE;
	}
	
	// GLFW config
	glfwSetErrorCallback(temp_error_callback);

	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);	
	
	GLFWwindow* window = glfwCreateWindow(WIN_WIDTH, WIN_HEIGHT, WIN_NAME, NULL, NULL);

	glfwSetKeyCallback(window, key_callback);
	glfwSetMouseButtonCallback(window, mouse_button_callback);
	glfwSetCursorEnterCallback(window, cursor_enter_callback);

	glfwMakeContextCurrent(window);
	glfwSwapInterval(1);

	std::cout << "test" << std::endl;
	if (!window) {
		std::cout << "Error, could not create window" << std::endl; 
	} else {
		if (!gl3wInit()) {
      //IMGUI_CHECKVERSION();
      ImGui::CreateContext();
      ImGuiIO &io = ImGui::GetIO();
      // Platform IMGUI
      ImGui_ImplGlfw_InitForOpenGL(window, true);
      ImGui_ImplOpenGL3_Init("#version 130");
      ImGui::StyleColorsDark();
			draw_loop(window);
		} else {
			std::cout << "Cannot init gl3w" << std::endl;
		}
		
	}

	glfwDestroyWindow(window);
	glfwTerminate();

	return 0;
}
